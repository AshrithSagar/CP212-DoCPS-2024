\section*{Question 4}

I continued running the code.
However, while running the code, I forgot to update the prototype in \texttt{main.c}, which remained:
\begin{lstlisting}[language=C]
int linear(int x);
\end{lstlisting}

I stepped through the code from \texttt{main} onwards.

In \texttt{main}, the value of global variable \texttt{x} was correctly shown as \texttt{10}.
But when I stepped into \texttt{linear}, I saw the argument \texttt{x} to have the value \texttt{1.40129846e-44}.
And when the function returned, the value of global variable \texttt{y} was shown as \texttt{1073741824}.

Why is this happening?
Is the compiler buggy?

\subsection*{Solution}

\begin{figure*}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/q4/_}
    \setlength{\abovecaptionskip}{-12pt}
    \caption{
        The value \( \hex{0xA} \) interpreted as in the IEEE 754 format
    }\label{fig:q4}
\end{figure*}

There is an issue of type mismatch here, which causes the compiler to interpret the value of \( x \) as a floating point number.
Initially, the value of \( x \) is correctly interpreted as \( 10 \), i.e., as an integer.
Thereby the contents of the register are \( \hex{0xA} \).
However, the function \texttt{linear} expects a floating point number as per what was written the function body, thereby causing the compiler to interpret the value of \( x \) as a floating point number, as shown in Figure~\ref{fig:q4}.
This is \underline{not the compiler's fault}, but rather just a programming error.

To check what this number is actually, we can compute it as follows:
When the exponent is \( \hex{00000000} \), a special rule is followed, where the value is treated as a \textit{denormalised number} /\textit{subnormal number}, thereby the hidden leading 1 in the mantissa is not considered and the actual exponent is taken as \( -126 \), i.e., the value here is given by:
\[
    \implies
    {(-1)}^0 \times 2^{ -126 } \times 0.\underbrace{0000000000000000000}_{19\text{ zeros}}1010_{2}
\]
\begin{equation*}
    \implies
    2^{ - 126 } \times (2^{-20} + 2^{-22})
    =
    \boxed{
        1.4012984643 \times 10^{-44}
    }
\end{equation*}

Now, when the function \texttt{linear} is run, it returns the value \( 5x + 2 \), which is computed in floating point arithmetic by first having \( 5 \) and \( 2 \) represented as floating point numbers, as seen previously in Figure~\ref{fig:q3-5} and Figure~\ref{fig:q3-2}, respectively.

We can verify the computations  manually.
Multiplying the mantissa's, we get
\begin{align*}
    \implies
    (2^{-20} + 2^{-22}) \times (1 + 2^{-2})
     & =
    2^{-20} + 2^{-22} + 2^{-22} + 2^{-24}
    \\ & =
    (2^{-20} + 2^{-21}+ 2^{-24})
    \\ & =
    2^{-20} \times (1 + 2^{-1}+ 2^{-4})
\end{align*}
Adding the exponents, we get
\[
    \implies
    (-126) + (129 - 127)
    =
    (3 - 127)
\]
Normalising the mantissa, we get
\begin{align*}
    \implies
     &
    + 2^{3 - 127} \times 2^{-20} \times (1 + 2^{-1}+ 2^{-4})
    \\ & =
    + 2^{-17 - 127} \times (1 + 2^{-1}+ 2^{-4})
\end{align*}
But this value can't be represented in the conventional floating point representation, since the exponent is too small.
Hence, this value becomes zero, which is the value of \( 5x \) in floating point representation.

Now, addition of the above value to 2 yields 2.0.
Thereby, the result of the operation \( 5x + 2 \) \underline{yields 2.0} here.
At the end of the function call, this value is stored as a floating point number, i.e., as \( \hex{0x40000000} \), which is the IEEE 754 representation of the number \( 2.0 \).
But since the prototype defines the return type as \( \texttt{int} \), the value is interpreted as an integer.
The decimal representation of \( \hex{0x40000000} \) is \( 2^{30} = \boxed{1073741824} \), which is the value that is stored in the global variable \( y \).

The \underline{compiler is not buggy}, but rather it is the fault of the programmer here.
